{
  "name": "angular-formly",
  "version": "4.0.5",
  "author": {
    "name": "Astrism",
    "email": "astrisms@gmail.com"
  },
  "contributors": [
    {
      "name": "Astrism",
      "email": "astrisms@gmail.com"
    },
    {
      "name": "Kent C. Dodds",
      "email": "kent@doddsfamily.us"
    }
  ],
  "homepage": "http://formly-js.github.io/angular-formly/",
  "repository": {
    "type": "git",
    "url": "git://github.com/formly-js/angular-formly.git"
  },
  "main": "dist/formly.js",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.githubusercontent.com/formly-js/angular-formly/master/LICENSE"
    }
  ],
  "scripts": {
    "build:dist": "node node_modules/webpack/bin/webpack.js",
    "build:prod": "node node_modules/webpack/bin/webpack.js --config webpack.config.minify.js",
    "build": "npm run build:dist; npm run build:prod",
    "test": "node node_modules/karma/bin/karma start karma.conf.js",
    "test:single": "node node_modules/karma/bin/karma start karma.conf.js --single-run",
    "test:ci": "node node_modules/karma/bin/karma start karma.conf.ci.js",
    "watch": "node node_modules/webpack/bin/webpack.js --watch",
    "start": "npm run watch & npm run test",
    "deploy": "grunt deploy",
    "release": "git push && npm publish && git push --tags"
  },
  "config": {
    "ghooks": {
      "pre-commit": "npm run test:single"
    }
  },
  "description": "AngularJS directive which takes JSON representing a form and renders to HTML",
  "peerDependencies": {
    "angular": "~1.x",
    "api-check": "^6.0.10"
  },
  "devDependencies": {
    "angular": "^1.3.11",
    "angular-mocks": "^1.3.11",
    "api-check": "^6.0.10",
    "babel-core": "^4.4.6",
    "babel-loader": "^4.0.0",
    "chai": "^1.10.0",
    "deep-extend": "^0.3.2",
    "ghooks": "^0.2.4",
    "grunt": "^0.4.5",
    "grunt-gh-pages": "^0.9.1",
    "imports-loader": "^0.6.3",
    "jshint": "2.6.0",
    "jshint-loader": "^0.8.1",
    "karma": "^0.12.31",
    "karma-chai": "^0.1.0",
    "karma-chrome-launcher": "^0.1.7",
    "karma-firefox-launcher": "^0.1.4",
    "karma-mocha": "^0.1.10",
    "karma-webpack": "^1.5.0",
    "loader-utils": "^0.2.6",
    "lodash": "^2.4.1",
    "lodash-node": "^2.4.1",
    "mocha": "^2.1.0",
    "ng-annotate": "^0.15.1",
    "raw-loader": "^0.5.1",
    "sinon": "git://github.com/cjohansen/Sinon.JS#sinon-2.0",
    "sinon-chai": "^2.6.0",
    "source-map": "^0.2.0",
    "webpack": "^1.5.3",
    "webpack-dev-server": "^1.7.0"
  },
  "readme": "[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/formly-js/angular-formly?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://travis-ci.org/formly-js/angular-formly.svg)](https://travis-ci.org/formly-js/angular-formly)\n\n# angular-formly\n\nFormly for Angular is an AngularJS module which has directives to help customize and render JavaScript configured forms.\nThe directive originated from a need to allow our users to create surveys and distribute them easily. Buckle up, because\nangular-formly is very powerful.\n\n```html\n<formly-form model=\"formData\" fields=\"formFields\"></formly-form>\n```\n\n## NOTICE: UPGRADING FROM 2.0 to 3.0?\n\nThere were some [significant changes](https://github.com/formly-js/angular-formly/blob/master/CHANGELOG.md) that you'll\nwant to be aware of. In order to upgrade and get all the cool features, you're going to need to change your field\nconfigurations. [Here is a tool](http://jsbin.com/ruwoke) that should help make that process easier. Also, if you are\nnot able to update the configuration very easily, see\n[this issue](https://github.com/formly-js/angular-formly/issues/162) for ideas on how to ease things a little.\n\n## Demo\n\nhttp://formly-js.github.io/angular-formly/\n\n## Dependencies\n\n - [Angular](https://angularjs.org/) - HTML enhanced for web apps\n - [apiCheck.js](https://github.com/kentcdodds/apiCheck.js) - VanillaJS version of ReactJS propTypes\n\n## Install in your project\n1. Install with bower or npm (or just download the script)\n\n `$ bower install angular-formly --save`\n\n or\n\n `$ npm install angular-formly --save`\n\n2. Include the javascript file in your index.html, Formly without any form templates. You can create your own or use\nsome of our prebuilt templates which cover basic form types, then extend with your own as needed.\n\n `<script src=\"bower_components/angular-formly/dist/formly.min.js\"></script>`\n\n and\n\n `angular.module('yourModule', ['formly']);`\n\n or\n\n `angular.module('yourModule', [require('angular-formly')]);`\n\n\n### Prebuilt Templates\n\nWhile it is recommended to create your own templates for ultimate customization and flexibility, there are prebuilt\ntemplates you can use:\n\n - [Vanilla HTML](https://github.com/formly-js/angular-formly-templates-vanilla)\n - [Bootstrap](https://github.com/formly-js/angular-formly-templates-bootstrap)\n - [LumX](https://github.com/formly-js/angular-formly-templates-lumx)\n - [angular-material](https://github.com/formly-js/angular-formly-templates-material) (WIP)\n - [Ionic](https://github.com/formly-js/angular-formly-templates-ionic): (WIP, owner needed)\n - [Foundation](https://github.com/formly-js/angular-formly-templates-foundation): (WIP, owner needed)\n\n### DIY Templates\n\nRegardless of which flavor you use (or if you use no flavor at all), you can create your own templates with\n`formlyConfigProvider`. This is the recommended approach if you want to customize your templates at all.\n\n## Documentation\n\n*Note:* This `README.md` is for the latest version of `formly`. Be sure to check that you're reading the right docs!\n\n`https://github.com/formly-js/angular-formly/tree/{{YOUR_VERSION}} <-- insert your version`\n\n### Example\n\nHere's an example using the vanilla template properties\n\nYou can add a formly-form in your HTML templates as shown below.\n```html\n<formly-form model=\"formData\" fields=\"formFields\">\n\t<button ng-click=\"onSubmit()\">Hello World</button>\n</formly-form>\n```\n\nExample data as it would be set in the controller\n```javascript\n$scope.formData = {};\n$scope.formFields = [\n  {\n    //the key to be used in the model values {... \"username\": \"johndoe\" ... }\n    key: 'username',\n    type: 'input',\n    templateOptions: {\n      label: 'Username',\n      placeholder: 'johndoe',\n      required: true,\n      description: 'Descriptive text'\n    }\n  },\n  {\n    key: 'password',\n    type: 'input',\n    templateOptions: {\n      type: 'password',\n      label: 'Password',\n      required: true\n    },\n    expressionProperties: {\n      'templateOptions.disabled': '!model.username' // disabled when username is blank\n    }\n  }\n];\n\n$scope.onSubmit = function() {\n  console.log('form submitted:', $scope.formData);\n};\n```\n\n### Creating Form Fields\nWhen constructing fields use the options below to customize each field object. You must set at least a `type`,\n`template`, or `templateUrl`.\n\n### Valid field options\n\nYou can only specify these properties. Additional properties will result in an error. If you need custom properties, use\n`templateOptions` or `data`.\n\n##### type (string)\n>`type` is the type of field to be rendered. Either type, template, or templateUrl must be set.\n\n---\n##### template (string)\n>`template` can be set instead of `type` or `templateUrl` to use a custom html template form field. Should be used with\none-liners mostly (like a directive). Useful for adding functionality to fields.\n\n**Note:** This can be used to add HTML instead of a form field.\n\nExamples:\n```html\ntemplate: '<p>Some text here</p>'\n```\n\n```html\ntemplate: '<hr />'\n```\n\n---\n##### templateUrl (string)\n>`templateUrl` can be set instead of `type` or `template` to use a custom html template form field. Set a path relative\nto the root of the application. ie `directives/custom-field.html`\n\n---\n##### key (string)\n>By default form models are keyed by location in the form array, you can override this by specifying a `key`.\n\n---\n##### hide (boolean)\n>Whether to hide the field (uses `ng-if`)\n\n---\n##### model (object)\n>By default, the `model` passed to the `formly-field` directive is the same as the `model` passed to the `formly-form`.\nHowever, if the field has a `model` specified, then the specified `model` is used for that field (and that field only).\nAlso, a deep watch is added to the `formly-field` directive's scope to run the `expressionProperties` when the specified\n`model` changes.\n\n---\n##### expressionProperties (object)\n>`expressionProperties` is an object where the key is a property to be set on the main field config (can be an angular\nexpression) and the value is an expression used to assign that property. The expression can be a function or string\nexpression and will be evaluated using `formlyEval` from `formlyUtils` see below for more information. The returned\nvalue is wrapped in `$q.when` so you can return a promise from your function :-)\n\nFor example:\n\n```javascript\nvm.fields = [\n  {\n    key: 'myThing',\n    type: 'someType',\n    expressionProperties: {\n      'templateOptions.label': '$viewValue', // this would make the label change to what the user has typed\n\n       // this would set that property on data to be whether or not model.myThing.length > 5\n      'data.someproperty.somethingdeeper.whateveryouwant': 'model.myThing.length > 5'\n    }\n  }\n];\n```\n\n---\n##### data (*)\n>`data` is reserved for the developer. You have our guarantee to be able to use this and not worry about future versions\nof formly overriding your usage and preventing you from upgrading :-)\n\n---\n##### templateOptions (*)\n>`templateOptions` is reserved for the templates. Any template-specific options go in here. Look at your specific\ntemplate implementation to know the options required for this.\n\n---\n##### wrapper (string|array of strings)\n>`wrapper` makes reference to `setWrapper` in the formlyConfigProvider. It is expected to be the name of the wrapper\nspecified there. The formly field will be wrapped by the first wrapper, then the second, then the third, etc.\n\n---\n##### ngModelAttrs (object)\n>`ngModelAttrs` is used in an angular-formly created templateManipulator to automatically add attributes to the ng-model\nelement of field templates. You will likely not use this often. This object is a little complex, but extremely powerful.\nIt's best to explain this api via an example. See the bottom for the example of this api.\n\n---\n##### controller (controller name|controller function)\n>`controller` is a great way to add custom behavior to a specific field. You can also set the controller to a type as\nwell. It is injectable with the $scope of the field, and anything else you have in your injector.\n\n---\n##### link (link function)\n>`link` allows you to specify a link function. It is invoked after your template has finished compiling. You are passed\nthe normal arguments for a normal link function.\n\n---\n##### optionsTypes (string|array of strings)\n>`optionsTypes` allows you to specify extra types to get options from. Duplicate options are overridden in later\npriority (index `1` will override index `0` properties). Also, these are applied *after* the `type`'s `defaultOptions`\nand hence will override any duplicates of those properties as well.\n\n---\n##### modelOptions (object)\n>`modelOptions` allows you to take advantage of `ng-model-options` directive. Formly's built-in templateManipulator (see\nbelow) will add this attribute to your `ng-model` element automatically if this property exists. Note, if you use the\n`getter/setter` option, formly's templateManipulator will change the value of `ng-model` to `options.value` which is a\ngetterSetter that formly adds to field options. For more information on ng-model-options, see\n[these](https://egghead.io/lessons/angularjs-new-in-angular-1-3-ng-model-options-getters-and-setters)\n[egghead](https://egghead.io/lessons/angularjs-new-in-angular-1-3-ng-model-options-updateon-and-debounce)\n[lessons](https://egghead.io/lessons/angularjs-new-in-angular-1-3-ngmodeloptions-allows-you-to-set-a-timezone-on-your-model).\n\n---\n##### watcher (object|array of watches)\n>`watcher` is an object which has at least two properties called `expression` and `listener`. The `watch.expression` is\nadded to the `formly-form` directive's scope. If it's a function, it will be wrapped and called with the field as the\nfirst argument, followed by the normal arguments for a watcher, followed the watcher's `stop` function. If it's not\ndefined, it will default to the value of the field. The `listener` will also be wrapped and called with the field as the\nfirst argument, followed by the normal arguments for a watch listener. You can also specify a type (`$watchCollection`\nor `$watchGroup`) via the `type` property (defaults to `$watch`) and whether you want it to be a deep watch via the\n`deep` property (defaults to `false`).\n\nHow the api differs from a normal `$watch`:\n\n```javascript\n// normal watcher\n$scope.$watch(function expression(theScope) {}, function listener(newValue, oldValue, theScope) {});\n\n// field watcher\n$scope.$watch(function expression(field, theScope, stop) {}, function listener(field, newValue, oldValue, theScope, stop) {});\n```\n\n---\n##### validators (object)\n>`validators` is an object where the keys are the name of the validity (to be passed to `$setValidity`) and the values\nare functions or expressions which returns true if it is valid. Templates can pass this option to the\n`formly-custom-validation` directive which will add a parser (or validator, see note) to the `ngModel` controller of\nthe field. The validator can be a function or string expression and will be evaluated using `formlyEval` from\n`formlyUtils` see below for more information.\n\n>**Async validation**: All function validators can return true/false/Promise. A validator passes if it returns true or\na promise that is resolved. A validator fails if it returns false or a promise that is rejected.\n\n>**1.2**: Formly defaults to use the `$validators` api, which is only available in angular 1.3. If you are using 1.2,\nthen the `$parsers` api is used which doesn't support async validation out of the box. However, formly will keep track\nof the validations for you and ensure that the most recently resolved/rejected promise is what takes priority. Also,\nwhile the validation is in flight, formly emulates the `$pending` api of 1.3 for your use in 1.2 as well, so you can\nsafely use this and upgrade to 1.3 without worrying about the upgrade path for this api. You're welcome :-)\n\n> **NOTE**: You can alternatively specify a validator as an object with an `expression` and a `message`. This will\nunify how templates reference messages for when the validator has failed. Also, this should be used only for one-off\nmessages (use `ng-messages-include` for generic messages). `message` in this case should be an expression that is\nevaluated in exactly the same way a validator is evaluated. The `formly-custom-validation` directive will then add an\nobject to the field options called `validationMessages` which is a map of functions where the key is the validation name\nand the value is a to function which returns the evaluated message.\n\n---\n##### validation (object)\n>`validation` is an object with a few useful properties mostly handy when used in combination with ng-messages\n\n>`validation.messages` a map of functions mapped to message names. These messages come from the validators. Invoke\nthese and angular-formly will evaluate them using `formlyUtil.formlyEval` (which is how validators themselves are\nevaluated.\n\n>`validation.errorExistsAndShouldBeVisible` a boolean indicating whether an error message should be shown. Because you\ngenerally only want to show error messages when the user has interacted with a specific field, this value is set to\ntrue based on this rule: `field invalid && (field touched || validation.show)`\n\n>`validation.show` is a boolean you as the developer can set to specify to force `errorExistsAndShouldBeVisible`\nto be set to true when there are `$errors`. This is useful when you're trying to call the user's attention to some\nfields for some reason.\n\n## Added Properties\n\nFormly will add a few properties to your field config for convenience in templates\n\n### formControl\n\nThis is the [NgModelController](https://docs.angularjs.org/api/ng/type/ngModel.NgModelController) for the field. It\nprovides you with awesome stuff like `$errors` :-)\n\n### value\n\nThis is a getter/setter function for the value that your field is representing. Useful when using `getterSetter: true`\nin the `modelOptions` (in fact, if you don't disable the templateManipulator that comes built-in with formly, it will\nautomagically change your field's `ng-model` attribute to use `value`.\n\n### runExpressions\n\nIt is not likely that you'll ever want to invoke this function. It simply runs the `expressionProperties` expressions.\nIt is used internally and you shouldn't have to use it, but you can if you want to.\n\n## CSS Classes\n\nThe resulting form element has the class `formly` and each field has the class `formly-field`.\n\n## Validation\n\nFormly uses angular's built-in validation mechanisms. See the [angular docs](https://docs.angularjs.org/guide/forms) for\nmore information on this. (Note, if you're using Angular 1.3, formly utilizies the new `$validators` and\n`$asyncValidators` pipelines, otherwise, it falls back to good old `$parsers`. Either way, your API is the same, though\nyou can't do asynchornous validation with 1.2.x).\n\nThe form controller is bound to what you specify as the `form` attribute on the `formly-form` directive. Make sure to\nspecify a name on any `ng-model` in your custom templates to ensure that the `formControl` is added to the `options`. If\nyou're using Angular 1.3, the `name` attribute is interpolateable (you can use `{{id}}`). If you are stuck on 1.2.x, you\ncan use the `formly-dynamic-name` directive where the value is an expression which would return the name (so,\n`formly-dynamic-name=\"id\"`). Formly will add a `formControl` property to the field, and you can reference that in your\ntemplate with `options.formControl` to get access to properties like `$invalid` or `$error`. See the bootstrap templates\nfor an example.\n\nYou can also specify custom validation in your JSON. See the field called `validators` for more information on this. If\nyou wish to leverage this in a custom template, use the `formly-custom-validation` directive and pass\n`options.validators` to it.\n\n## directives\n\n### formly-form\n\nThis the the main directive you'll use throughout your code. A word of advice, create your own directive that wraps this\none. This will make any upgrades easier if the api changes at all. If you want an example of how to do this, file an\nissue and I'll demonstrate :-D\n\nThe attributes allowed on the directive are as follows:\n\n#### model\n\nThe model to be represented by the form.\n\n#### fields\n\nThe field configurations for building the form\n\n#### form\n\nThe variable to bind the `NgFormController` to.\n\n#### root-el\n\nYou will not likely use this often. The value given will control what is used for the formly-form's root element. It\ndefaults to an `ng-form`, but if you want it to use a `form` or a `div` then you would specify `root-el=\"form\"` or\n`root-el=\"div\"` (respectively). If you choose anything except a `form` or `ng-form`, make sure to wrap it in your own\n`ng-form` or `form` and provide that with a `name`. Then pass that `name` to the `form` attribute so all the\n`formControls` of the fields will have somewhere to be added to.\n\n### formly-field\n\nYou will not likely need to use this directive, but if you do just know that unless you're using it inside `formly-form`\nyou're fields are not going to get all the treatment (like `watchers` for example).\n\n#### options\n\nThe field config. Must have a `type` OR `template` OR `templateUrl`. Everything else is optional, but it is limited to\nthe options mentioned above. Any extra options will result in an error.\n\n#### model\n\nThe model for the field to represent\n\n#### formId\n\nThe id of the form, used to generate the id for the field which is used in the `name` (for the `formControl`) and the id\nof the field (useful for a `label`'s `for` attribute)\n\n#### index\n\nThe index of the field, used if `key` is not defined on the field.\n\n#### fields\n\nThe other fields. As convenience if needed.\n\n#### form\n\nThe `NgFormController` that will be used to get and set the `formControl` for the field.\n\n### formly-custom-validation\n\nThis is an attribute directive. The given value should be a `validators` object.\n\n### formly-focus\n\nThis is an attribute directive. It will watch the given value and focus the element when the given value is truthy. You\ncan also optionally add a `refocus` attribute and this will cause focus to be returned to the previous element with\nfocus when the `formly-focus` value is set to falsey (unless the user has clicked away from the focused element).\n\n## formlyConfigProvider\n\nThis is where you'll be configuring angular-formly to inform it of your templates and other options. You can do most\nthings in either the `config` function with the `formlyConfigProvider` or in the `run` function with the `formlyConfig`.\n\n### setType\n\nAllows you to specify a custom type\n\n```javascript\n// object api (single type with a template)\nformlyConfig.setType({\n  name: 'input',\n  template: '<input ng-model=\"[options.key]\" />'\n});\n// with a templateUrl\nformlyConfig.setType({\n  name: 'checkbox',\n  templateUrl: 'custom-formly-fields-checkbox.html'\n});\n\n// array api (multiple types)hi\nformlyConfig.setType([\n  {\n    name: 'radio',\n    templateUrl: 'custom-formly-fields-radio.html'\n  },\n  {\n    name: 'button',\n    templateUrl: '<button ng-click=\"options.templateOptions\">{{options.label}}</button>'\n  }\n]);\n\n// also, you can specify wrappers for a type\nformlyConfig.setType({\n  name: 'select',\n  templateUrl: 'custom-formly-fields-select.html',\n  wrapper: ['inner', 'outer', 'evenOuterOuter']\n});\n\n// you can also set default options for fields of this type. This can be done with or without a template or templateUrl\n// useful when combined with the field's `optionsTypes` property.\nformlyConfig.setType({\n  name: 'phone',\n  defaultOptions: {\n    templateOptions: {\n      pattern: '^1[2-9]\\d{2}[2-9]\\d{6}$'\n    }\n  }\n});\n\n// you also have the option to specify a controller and a link function\nformlyConfig.setType({\n  name: 'uploadButton',\n  controller: function($scope, $upload) {\n    $scope.onUploadClicked = function(file) {\n      return $upload.start(file); // whatever...\n    }\n  },\n  link: function(scope, el) {\n    el.addClass('manipulate-the-dom');\n  }\n});\n```\n\n#### name (string, required)\n\nThe name of the template type. You use this in the `type` option of a field.\n\n#### template (string)\n\nThe template for the field. This is required if there is no `templateUrl` or `defaultOptions`. Angular-formly will throw\nan error if this is present with a `templateUrl` (but works fine with `defaultOptions`).\n\n#### templateUrl (string)\n\nA url pointing to a template for the field. This is required if there is no `template` or `defaultOptions`.\nAngular-formly will throw an error if this is present with a `template` (but works fine with `defaultOptions`).\n\n#### defaultOptions (object|function)\n\nOptions to be used by default for the field. These are merged with the field options for all fields of this type as well\nas all fields specifying this type as an `optionsTypes`. This is required if there is no `template` or `templateUrl`\nspecified. And works fine if supplied in addition to either. If a function is supplied, it will be passed the options of\nthe field and is supposed to return the default options (don't do the merging yourself, just pass what you want to be\nused for the default for this configuration).\n\n#### extends (string)\n\nThis allows you to extend the functionality of other types. It merges the options specified with the parent's options\nand it will even gracefully handle situations where the parent has link/controller/defaultOptions functions as well.\nNote: in the case of a wrapper conflict, don't use this feature as it just gets too complicated, create a new type\ninstead.\n\n#### wrapper (string|array of strings)\n\nSpecify the name of wrappers that you want fields of this type to be wrapped in by default.\n\n#### controller (string|injectable function)\n\nThis function will be invoked (using the `$controller` service) at the end of the `formly-field` controller (before the\nfield's `controller` if specified). It can inject anything in the `$injector` as well as the `$scope` of the\n`formly-field`. If it is a string, it must be the name of a controller that has been registered with angular. If this\ntype extends another, this function will be run *after* the parent controller function is run.\n\n#### link (function)\n\nThis function will be invoked after the `formly-field` link function has been invoked (before the field's `link` if\nspecified). It is invoked with all the normal arguments of a regular link function. If the type extends another, this\nfunction will be run *after* the parent link function is run.\n\n#### apiCheck (objectOf(func))\n\nThis is specific to the use of the `apiCheck.js` library. This is the preferred method for validating options as it\nallows for tooling to discover what the api to your type is.\n\n```javascript\nngModule.constant('yourOwnCheck', apiCheck({\n  output: {prefix: 'you app/lib name'}\n}));\nngModule.run(function(formlyConfig, yourOwnCheck) {\n  formlyConfig.setType({\n    name: 'input',\n    template: '<input class=\"to.className\" ng-model=\"model[options.key]\" />',\n    apiCheck: {\n      templateOptions: yourOwnCheck.shape({\n        className: yourOwnCheck.string\n      })\n    },\n    apiCheckInstance: yourOwnCheck\n  });\n});\n```\n\n#### apiCheckInstance (apiCheck instance)\n\nYour own instance of apiCheck so you have the correct prefix/suffix/url/etc.\n\n#### apiCheckFunction ('throw' or 'warn')\n\nAllows you to customize whether your check throws and error or simple warns. Defaults to warn.\n\n#### apiCheckOptions (object)\n\nThe options to use when the check fails. Defaults to something sensible.\n\n#### validateOptions (function)\n\nNote: It is recommended that you use `apiCheck` with `apiCheckInstance` rather than `validateOptions`.\n\nThis function will be invoked with the options of the field after it has been merged with it's `optionsDefaults` and\nany types that its type `extends`. Feel free to log warnings to the console or throw errors here to help users use your\ntypes correctly. Recommended: Use [apiCheck.js](https://github.com/kentcdodds/apiCheck.js) as this is what formly uses\nand will already be available to you. You can inject this dependency with `apiCheck`. You can use it like so:\n\n```javascript\nngModule.run(function(formlyConfig, yourOwnCheck) {\n  formlyConfig.setType({\n    name: 'input',\n    template: '<input ng-model=\"model[options.key]\" />',\n    validateOptions: function(options) {\n      yourOwnCheck.throw(yourOwnCheck.object, arguments);\n    }\n  });\n});\n```\n\n### setWrapper, getWrapper, getWrapperByType, removeWrapperByName, & removeWrappersForType\n\nAllows you to set a template for your formly templates. You can have a default (used by all templates), named template\nwrappers, and typed template wrappers (used by fields with the specified type). All template wrappers must follow these\nrules\n - Use `<formly-transclude></formly-transclude>` in them to specify where the field template should be placed.\n - Have at least one, and only one of `templateUrl` or `template`\n - Not override another by name or type\n\nFor example:\n\n```javascript\n// simple argument api\nformlyConfigProvider.setWrapper(\n  '<div>This is the default because <formly-transclude></formly-transclude> there is no name specified</div>'\n);\nformlyConfigProvider.setWrapper(\n  '<div>This is not the default because <formly-transclude></formly-transclude> there is a name specified</div>',\n  'theName'\n);\n\n// object api\nformlyConfigProvider.setWrapper({\n  name: 'inputWrapper', // optional. Defaults to name || types.join(' ') || 'default'\n  template: 'the template with <formly-transclude></formly-transclude> in it', // must have this OR templateUrl\n  templateUrl: 'path/to/template.html', // the resulting template MUST have <formly-transclude></formly-transclude> in it and must have templateUrl OR template (not both)\n  types: 'stringOrArray' // this can be a string or an array of strings that map to types specified by setTemplate and setTemplateUrl\n});\n\n// array api\nformlyConfigProvider.setWrapper([\n  { /* same configuration as the object api */ },\n  { /* same configuration as the object api */ },\n  { /* same configuration as the object api */ },\n  { /* same configuration as the object api */ }\n]);\n```\n\n`removeWrapperByName` and `removeWrappersForType` are helpful if you're using a template library but want to customize\nyour own wrappers. The api is simple:\n\n```javascript\nformlyConfigProvider.removeWrapperByName('inputWrapper'); // removes the wrapper that's called 'inputWrapper'\nformlyConfigProvider.removeWrappersForType('select'); // removes all wrappers that apply to the type of 'select'\n```\n\nAlso, note, that if you want to remove the default wrapper, this is done by passing `'default'` to the\n`removeWrapperByName` function.\n\nAnother note, you can instead override wrappers (and types as well) without a warning if you specify an\n`overwriteOk: true` property.\n\nSee [the website](https://formly-js.github.io/angular-formly/) for examples on usage\n\n### templateManipulators\n\nThis allows you to manipulate the template of a specific field. This gives you a great deal of power without sacrificing\nperformance by having bindings which you will never need as well as save repetition in your templates. The api to this\nfeature is as follows:\n\n```javascript\n// note, most of the formlyConfigProvider functions can\n// actually be done in the `run` function as well using `formlyConfig`.\nformlyConfigProvider.templateManipulators.preWrapper.push(function(template, options, scope) {\n  // determine if you wish to do anything with this template,\n  // manipulated as needed, and return either the old template,\n  // the new template, or a promise that will resolve with the\n  // new template... for example\n  if (options.data.addWarningMessage) {\n    return template + '<div>This is a warning message!!!</div>';\n  } else {\n    return template;\n  }\n});\n\n// or, if you wanted to load a template, you would do it in the\n// run function so you can get $http, and $templateCache, then do:\nformlyConfig.templateManipulators.preWrapper.push(function(template, options, scope) {\n  return $http.get('the/template.html', {cache: $templateCache}).then(function(response) {\n    return response.data.replace('where-the-template-goes', template);\n  });\n});\n```\n\n#### ngModelAttrsTemplateManipulator\n\nNote! This is probably one of the coolest parts of angular-formly! There is a *built-in* `templateManipulator` that\nautomatically adds attributes to the `ng-model` element(s) of your templates for you. Here are the things you need to\nknow about it:\n\n- It will never override existing attributes\n- To prevent it from running on your field, simply set `data: {noTouchy: true}` and this template manipulator will skip\nyours\n- This can be disabled globally by setting `formlyConfigProvider.extras.disableNgModelAttrsManipulator = true`\n- It wont do anything to the template if it can't find any elements with the attribute `ng-model`.\n- It first goes through the `bound` and `unbound` `ngModelAttrs` specified for the field (read more about that above)\n- It adds a `name` and `id` attribute (the `scope.id` for both of them)\n- It adds the `formly-custom-validation` directive if the field has `options.validators`\n- It adds `ng-model-options` directive if the field has `options.modelOptions`\n- It utilizes the `ngModelAttrs` api to add a bunch of attributes automagically. This is probably one of the coolest\nthings about angular-formly. See below for examples of how to use this.\n\n```javascript\n{\n  templateOptions: {\n    placeholder: 'This will be automagically added',\n    required: true, // will add a required attribute\n    maxlength: 6, // this would add a maxlength attribute, but see expressionProperties\n    onBlur: 'options.data.hasBeenBlurred = true' // this adds ng-blur\n  },\n  expressionProperties: {\n    'templateOptions.maxlength': 'someExpression' // this adds the ng-maxlength attribute\n  }\n}\n```\n\nThis is incredibly powerful because it makes the templates require much less bloat AND it allows you to avoid paying the\ncost of watchers that you'd never use (like a field that will never be required for example).\n\nHere are the built-in supported attributes\n\n> both attribute or regular attribute -> required, disabled, pattern, maxlength, and minlength\n> attribute only -> placeholder, min, max, tabindex, and type\n> expression types -> onChange, onKeydown, onKeyup, onKeypress, onClick, onFocus, and onBlur\n\nYou can add more custom attributes using the `ngModelAttrs` api. It's a little complex, but quite powerful.\n\n\n### disableWarnings\n\nFormly gives some useful warnings when you attempt to use a template that doesn't exist or there's a problem loading a\ntemplate. You can disable these warnings via `formlyConfigProvider.disableWarnings = true`\n\n## formlyValidationMessages\n\nThis service allows you to control what messages gets added to each field's `validation.messages` which can ultimately\nbe used in an `ng-messages` context to great effect. It has a `messages` property which is what is used to attach the\n`messages` to the field's config. The messages here should be set as angular expressions (or functions) similar to how\n`expressionProperties` or `validators` works. You can always interact with `messages` on your own, but there are two\nhelper methods in this service\n\n### addTemplateOptionValueMessage\n\n```javascript\nformlyValidationMessages.addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate);\n// for example\nformlyValidationMessages.addTemplateOptionValueMessage('max', 'max', 'The max value allowed is', '', 'Too big');\nformlyValidationMessages.addTemplateOptionValueMessage('minlength', 'minlength', '', 'is the minimum length', 'Too short');\nformlyValidationMessages.addTemplateOptionValueMessage('pattern', 'patternValidationMessage', '', '', 'Invalid Input');\n\n// the last could be used like so:\nvar field = {\n  type: 'whatever',\n  templateOptions: {\n    pattern: /some_crazyPattern/,\n    patternValidationMessage: '\"Needs to match \" + options.templateOptions.pattern'\n  }\n};\n```\n\n### addStringMessage\n\n```javascript\nformlyValidationMessages.addStringMessage(name, string);\n// for example\nformlyValidationMessages.addStringMessage('required', 'This field is required');\n```\n\n## Tips and Tricks\n\nPlease see [the Wiki](https://github.com/formly-js/angular-formly/wiki) for tips and tricks from the community.\n\n## Expressions\n\nThere are four places where you can put expressions. The context in which these expressions are evaluated is important.\nThere are two different types of context and each is explained below:\n\n1) watcher - expression and listener can be functions or expression strings. This is a regular angular `$watch`\n(depending on the specified `type`) function and it is created on the `formly-form` scope, despite being applied to a\nspecific field. This allows the expressions to run even if the field's scope has been destroyed (via an ng-if like when\nthe field is hidden). The function signature differs from a normal `$watch` however. See above for more details.\n\n2) expressionProperties, validators, & messages - these expressions can be functions or expression strings. If it's a\nfunction, it's invoked with the arguments `$viewValue`, `$modelValue`, and `scope`. The scope in this case, is the\nfield's scope. If it's an expression string, it is evaluated using `$scope.$eval` with a locals object that has\n`$viewValue` and `$modelValue` (however, in the case of `expressionProperties`, `$viewValue` will simply be the\n`$modelValue` because ok into the `ngModelController` but we want to keep the api consistent).\n\n## Custom Templates\n\nYou have a lot of freedom when it comes to writing templates. You don't even need to use the `model` which means that\nyou can have fields that are just part of the look and feel of your form. Because of angular-formly's\n[ngModelAttrsTemplateManipulator](#ngmodelattrstemplatemanipulator), you really only have to put the `ng-model` element\nwhere you want it (if you want it at all) and formly will take care of most of the rest. If you want to have any extra\nproperties, you have pretty much full reign over the `options.templateOptions` object. Just be aware that angular-formly\ndoes make use of common parameters like `required` or `onClick` to automatically add attributes to `ng-model` elements.\n\n## apiCheck\n\nangular-formly uses [apiCheck.js](https://github.com/kentcdodds/apiCheck.js) to do type validation to help you use\nformly correctly. If you wish to disable this (in production that is recommended) then simply inject `apiCheck` and\ndisable it with `apiCheck.disable()`.\n\n## Roadmap\n\n- See the [issues labeled enhancement](labels/enhancement)\n\n## Contributing\n\nPlease see the [CONTRIBUTING Guidelines](CONTRIBUTING.md).\n\n## Thanks\n\nA special thanks to [Nimbly](http://gonimbly.com) for creating/sponsoring Angular-Formly's development.\nThanks to [Kent C. Dodds](https://github.com/kentcdodds) for his continued support on the project.\n\n---\n\n# Appendix\n\n## ngModelAttrs example\n\nThis api is a little complex. Hopefully these examples will be instructive.\n\nConfig like this:\n\n```javascript\n{\n  ngModelAttrs: {\n    myCustomValue: {\n      bound: 'ng-my-custom-value',\n      attribute: 'my-custom-value'\n    }\n  },\n  templateOptions: {\n    myCustomValue: 3\n  }\n}\n```\n\nWould yield something like this:\n\n```html\n<input ng-model=\"model[options.key]\" my-custom-value=\"3\" />\n```\n\nThe value is simply placed on the element using the attribute specified in `attribute`.\n\nWhereas if you changed the config to have an expressionProperty like this:\n\n```javascript\n{\n  ngModelAttrs: {\n    myCustomValue: {\n      bound: 'ng-my-custom-value',\n      attribute: 'my-custom-value'\n    }\n  },\n  templateOptions: {\n    myCustomValue: 3\n  },\n  expressionProperties: {\n    'templateOptions.myCustomValue': 'someEvaluationToGetCustomValue'\n  }\n}\n```\n\nThen the output would look like this:\n\n```html\n<input ng-model=\"model[options.key]\" ng-my-custom-value=\"options.templateOptions['myCustomValue']\" />\n```\n\nBecause the value of `templateOptions.myCustomValue` can change, it now uses the `bound` version of the attribute.\nHowever, if there is no `bound` version specified, but it is still an expression property like so:\n\n```javascript\n{\n  ngModelAttrs: {\n    myCustomValue: {\n      attribute: 'my-custom-value'\n    }\n  },\n  templateOptions: {\n    myCustomValue: 3\n  },\n  expressionProperties: {\n    'templateOptions.myCustomValue': 'someEvaluationToGetCustomValue'\n  }\n}\n```\n\nThen the output would look like this:\n\n```html\n<input ng-model=\"model[options.key]\" my-custom-value=\"{{options.templateOptions['myCustomValue']}}\" />\n```\n\nYou also have `expression`. For `expression` a config like this:\n\n```javascript\n{\n  ngModelAttrs: {\n    doAction: {\n      expression: 'do-something-awesome'\n    }\n  },\n  templateOptions: {\n    doAction: 'options.data.actionDone = true'\n  }\n}\n```\n\nWould result in output like this:\n\n```html\n<input ng-model=\"model[options.key]\" do-something-awesome=\"$eval(options.templateOptions['doAction'])\" />\n```\n\nHowever, if the `templateOptions.doAction` is a function instead, like this:\n\n```javascript\n{\n  ngModelAttrs: {\n    doAction: {\n      expression: 'do-something-awesome'\n    }\n  },\n  templateOptions: {\n    doAction: function(value, options, scope, $event) {\n      options.data.actionDone = true;\n    }\n  }\n}\n```\n\nThen the output would look more like this:\n\n```html\n<input ng-model=\"model[options.key]\" do-something-awesome=\"options.templateOptions['doAction'](model[options.key], options, this, $event)\" />\n```\n\nWhich allows you to have access to the `value`, `options`, `scope`, and `$event` as you see in the example.\n\nFinally, you can specify the custom attribute as a `value`. In this case, a config like this:\n\n```javascript\n{\n  ngModelAttrs: {\n    '{{options.data.whatever}}': {\n      value: 'my-whatever-attribute'\n    }\n  }\n}\n```\n\n```html\n<input ng-model=\"model[options.key]\" my-whatever-attribute=\"{{options.data.whatever}}\" />\n```\n\nWhich gives you the liberty to specify exactly the value you wish for your attribute in the template.\n\n",
  "readmeFilename": "README.md",
  "gitHead": "54dbb67f724320e3caf40a5beeca9e75682e54b4",
  "bugs": {
    "url": "https://github.com/formly-js/angular-formly/issues"
  },
  "_id": "angular-formly@4.0.5",
  "_shasum": "f899b8da555280ecc4494331923342bc9f84c989",
  "_from": "angular-formly@*"
}
